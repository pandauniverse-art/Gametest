<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Render Rush: Auto Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #121212; font-family: 'Pretendard', sans-serif; color: white; user-select: none; }
        canvas { display: block; }
        
        .ui-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0, 0, 0, 0.9); z-index: 100; transition: opacity 0.5s; }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 { font-size: 60px; margin-bottom: 20px; text-align: center; text-transform: uppercase; }
        p.desc { font-size: 20px; color: #ccc; margin-bottom: 40px; text-align: center; line-height: 1.6; }
        
        button { padding: 15px 50px; font-size: 24px; font-weight: bold; border: none; border-radius: 50px; cursor: pointer; transition: 0.2s; background: white; color: black; }
        button:hover { transform: scale(1.1); background: #00e5ff; }
        
        #hud-layer { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; display: none; }
        .hud-text { font-size: 24px; font-weight: bold; margin-bottom: 10px; }
        #stage-display { color: #ffe600; }
        #score-display { color: #00e5ff; }
        
        .theme-blue { color: #00e5ff; }
        .theme-red { color: #ff2a6d; }
        .theme-green { color: #00ff88; }
        
        /* ìŠ¤í‚¬ ë°œë™ ì‹œ í™”ë©´ ì¤‘ì•™ í…ìŠ¤íŠ¸ */
        #skill-alert { 
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 50px; font-weight: bold; color: #fff; text-shadow: 0 0 20px #00e5ff;
            pointer-events: none; display: none; z-index: 50;
            animation: popUp 0.5s ease-out forwards;
        }

        @keyframes popUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        #progress-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 80%; height: 10px; background: #333; border-radius: 5px; overflow: hidden; display: none; }
        #progress-bar { width: 0%; height: 100%; background: #00e5ff; transition: width 0.1s linear; }
        #error-log { display: none; position: absolute; top: 10px; right: 10px; background: rgba(255, 0, 0, 0.8); color: white; padding: 20px; z-index: 999; font-size: 14px; max-width: 300px; }
    </style>
</head>
<body>

    <div id="error-log"></div>
    <div id="skill-alert">ULTIMATE!</div>

    <div id="start-screen" class="ui-screen">
        <h1 class="theme-blue">RENDER RUSH <span style="font-size:40px">ğŸš€</span></h1>
        <p class="desc">
            <span style="color:#00e5ff">ë§ˆìš°ìŠ¤ ì´ë™:</span> ì¡°ì¢… / <span style="color:#ffe600">ì¢Œí´ë¦­:</span> ìë™ ë°œì‚¬<br>
            <span style="color:#d500f9">500ì  ë§ˆë‹¤:</span> ë¶€ì±„ê¼´ í•„ì‚´ê¸° ìë™ ë°œì‚¬!<br>
            2000ì ì— ë³´ìŠ¤ê°€ ë“±ì¥í•©ë‹ˆë‹¤.
        </p>
        <button id="start-btn">PROJECT START</button>
    </div>
    
    <div id="fail-screen" class="ui-screen hidden">
        <h1 class="theme-red">RENDER FAILED ğŸ’¥</h1>
        <p class="desc">ì¹˜ëª…ì ì¸ ì—ëŸ¬ì™€ ì¶©ëŒí–ˆìŠµë‹ˆë‹¤.</p>
        <button onclick="restartGame()">RETRY</button>
    </div>
    
    <div id="clear-screen" class="ui-screen hidden">
        <h1 class="theme-green">COMPLETE! ğŸ‰</h1>
        <p class="desc">ë³´ìŠ¤(ë©”ëª¨ë¦¬ ëˆ„ìˆ˜)ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤.<br>ì™„ë²½í•œ í‡´ê·¼ì…ë‹ˆë‹¤!</p>
        <button onclick="restartGame()">NEW PROJECT</button>
    </div>

    <div id="hud-layer">
        <div id="stage-display" class="hud-text">STAGE 1</div>
        <div id="score-display" class="hud-text">SCORE: 0</div>
    </div>
    <div id="progress-container"><div id="progress-bar"></div></div>

    <canvas id="gameCanvas"></canvas>

    <script>
        window.onerror = function(msg, url, line) {
            const errBox = document.getElementById('error-log');
            errBox.style.display = 'block';
            errBox.innerHTML = `<strong>ì˜¤ë¥˜ ë°œìƒ!</strong><br>${msg}<br>Line: ${line}`;
            return false;
        };

        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playTone(frequency, duration, type = 'sine', vol = 0.05) {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.type = type;
                oscillator.frequency.value = frequency;
                gainNode.gain.setValueAtTime(vol, audioCtx.currentTime);
                oscillator.start();
                setTimeout(() => {
                    if(gainNode && audioCtx) {
                        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.05);
                        oscillator.stop(audioCtx.currentTime + 0.05);
                    }
                }, duration);
            } catch(e) {}
        }

        function sfxHit() { playTone(200, 50, 'sawtooth'); }
        function sfxBossHit() { playTone(100, 50, 'square', 0.1); }
        function sfxSkill() { playTone(400, 100, 'sine'); setTimeout(()=>playTone(800, 300, 'square'), 100); }
        function sfxStageClear() { playTone(880, 100); setTimeout(() => playTone(1100, 200), 100); }
        function sfxGameOver() { playTone(150, 300, 'sawtooth'); playTone(100, 300, 'square'); }
        function sfxGameWin() { playTone(523, 100); setTimeout(() => playTone(659, 100), 100); setTimeout(() => playTone(784, 400), 400); }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const failScreen = document.getElementById('fail-screen');
        const clearScreen = document.getElementById('clear-screen');
        const hudLayer = document.getElementById('hud-layer');
        const skillAlert = document.getElementById('skill-alert');
        const stageEl = document.getElementById('stage-display');
        const scoreEl = document.getElementById('score-display');
        const startBtn = document.getElementById('start-btn');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');

        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

        const stages = [
            { level: 1, duration: 500, spawnRate: 30, enemySpeed: 3, name: "STAGE 1: PRE-RENDER" },
            { level: 2, duration: 1000, spawnRate: 20, enemySpeed: 5, name: "STAGE 2: MAIN RENDER" },
            { level: 3, duration: 1500, spawnRate: 15, enemySpeed: 8, name: "STAGE 3: FINALIZING..." }
        ];
        
        const BOSS_SPAWN_SCORE = 2000;
        const SKILL_INTERVAL = 500; // 500ì ë§ˆë‹¤ ë°œë™

        let isRunning = false; 
        let animationId; 
        let score = 0; 
        let currentStageIndex = 0;
        
        let mouse = { x: canvas.width/2, y: canvas.height/2 };
        let isMouseDown = false;

        let particles = []; let enemies = []; let missiles = [];
        let player = { size: 40, emoji: 'ğŸš€' }; 
        let boss = null;

        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => { isMouseDown = true; });
        window.addEventListener('mouseup', () => { isMouseDown = false; });
        window.addEventListener('touchmove', e => { mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }, {passive:false});
        window.addEventListener('touchstart', (e) => { isMouseDown = true; mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }, {passive:false});
        window.addEventListener('touchend', () => { isMouseDown = false; });

        startBtn.addEventListener('click', () => { startGame(); });

        class Boss {
            constructor() {
                this.x = canvas.width / 2;
                this.y = -100;
                this.targetY = 150;
                this.size = 100;
                this.hp = 1000;
                this.maxHp = 1000;
                this.emoji = 'ğŸ‘¹';
                this.speedX = 5;
                this.speedY = 3;
                this.entered = false;
            }

            update() {
                if (!this.entered) {
                    this.y += 2;
                    if (this.y >= this.targetY) this.entered = true;
                    return;
                }
                this.x += this.speedX;
                this.y += this.speedY;
                if (this.x < 50 || this.x > canvas.width - 50) this.speedX *= -1;
                if (this.y < 50 || this.y > canvas.height / 2) this.speedY *= -1;
                if (Math.random() < 0.02) this.speedX *= -1;
                if (Math.random() < 0.02) this.speedY *= -1;
            }

            draw() {
                ctx.font = `${this.size}px serif`;
                ctx.fillText(this.emoji, this.x, this.y);

                const barW = 200; const barH = 20;
                const hpPercent = Math.max(0, this.hp / this.maxHp);
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barW/2, this.y - 80, barW, barH);
                ctx.fillStyle = '#ff2a6d';
                ctx.fillRect(this.x - barW/2, this.y - 80, barW * hpPercent, barH);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(this.x - barW/2, this.y - 80, barW, barH);
                
                ctx.font = '16px serif';
                ctx.fillStyle = 'white';
                ctx.fillText(`MEMORY LEAK: ${this.hp}`, this.x, this.y - 90);
            }
        }

        // [ì—…ë°ì´íŠ¸] ë¯¸ì‚¬ì¼ í´ë˜ìŠ¤: ê°ë„ ì§€ì›
        class Missile {
            constructor(x, y, angle = 0, isUltimate = false) {
                this.x = x; this.y = y;
                this.size = isUltimate ? 30 : 20;
                this.speed = 15;
                this.emoji = isUltimate ? 'ğŸ”¥' : 'âš¡'; // í•„ì‚´ê¸°ëŠ” ë¶ˆê½ƒ
                
                // ê°ë„ì— ë”°ë¥¸ ì†ë„ ê³„ì‚° (angleì´ 0ì´ë©´ ìœ„ë¡œ ì§ì§„)
                // Math.sin, Math.cosë¥¼ ì‚¬ìš©í•˜ì—¬ vx, vy ê³„ì‚°
                // angleì€ ë¼ë””ì•ˆ ë‹¨ìœ„. 0ë„ = 12ì‹œ ë°©í–¥ ê¸°ì¤€
                this.vx = Math.sin(angle) * this.speed;
                this.vy = -Math.cos(angle) * this.speed;
            }
            update() { 
                this.x += this.vx;
                this.y += this.vy;
            }
            draw() { ctx.fillText(this.emoji, this.x, this.y); }
        }

        class Enemy {
            constructor(speedMultiplier) {
                this.x = Math.random() * canvas.width;
                this.y = -50;
                this.size = Math.random() * 30 + 20;
                this.speed = (Math.random() * 2 + 2) + speedMultiplier;
                this.emoji = 'ğŸ’¥';
                this.rotation = Math.random() * Math.PI * 2;
                this.spinStr = (Math.random() - 0.5) * 0.1;
                this.markedForDeletion = false;
            }
            update() { this.y += this.speed; this.rotation += this.spinStr; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.fillText(this.emoji, 0, 0); ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, type = 'tail') {
                this.x = x; this.y = y; this.opacity = 1;
                if (type === 'explosion') {
                    this.size = Math.random() * 15 + 10; this.emoji = 'âœ¨';
                    this.vx = (Math.random() - 0.5) * 10; this.vy = (Math.random() - 0.5) * 10; this.decay = 0.1;
                } else {
                    this.size = Math.random() * 15 + 10; this.y = y + 20; this.emoji = 'ğŸ”¥';
                    this.vx = 0; this.vy = 2; this.decay = 0.1;
                }
            }
            update() { this.opacity -= this.decay; this.size -= 1; this.x += this.vx; this.y += this.vy; }
            draw() { if(this.opacity < 0.1) return; ctx.globalAlpha = this.opacity; ctx.fillText(this.emoji, this.x, this.y); ctx.globalAlpha = 1; }
        }

        function startGame() {
            try {
                initAudio();
                startScreen.classList.add('hidden'); failScreen.classList.add('hidden'); clearScreen.classList.add('hidden');
                hudLayer.style.display = 'block'; 
                progressContainer.style.display = 'block';
                document.body.style.cursor = 'none';
                
                score = 0; currentStageIndex = 0;
                enemies = []; particles = []; missiles = []; boss = null;
                isRunning = true; isMouseDown = false;
                
                ctx.font = '30px serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                
                animate();
            } catch(e) { alert("Error: " + e.message); }
        }

        // [í•µì‹¬ ê¸°ëŠ¥] í•„ì‚´ê¸° ë°œì‚¬ (ë¶€ì±„ê¼´)
        function fireUltimate() {
            sfxSkill();
            
            // UI ì•Œë¦¼
            skillAlert.style.display = 'block';
            skillAlert.style.animation = 'none'; // ë¦¬ì…‹
            skillAlert.offsetHeight; /* trigger reflow */
            skillAlert.style.animation = 'popUp 1s ease-out forwards';

            const bulletCount = 20;
            const spreadAngle = Math.PI / 1.5; // 120ë„ ì •ë„ì˜ ë¶€ì±„ê¼´
            const startAngle = -spreadAngle / 2;
            const step = spreadAngle / (bulletCount - 1);

            for (let i = 0; i < bulletCount; i++) {
                const angle = startAngle + (step * i);
                // (x, y, angle, isUltimate)
                missiles.push(new Missile(mouse.x, mouse.y - 20, angle, true));
            }
        }

        function createExplosion(x, y) {
            for(let i=0; i<3; i++) particles.push(new Particle(x, y, 'explosion'));
        }

        function animate() {
            if (!isRunning) return;
            animationId = requestAnimationFrame(animate);

            // ì¼ë°˜ ìë™ ë°œì‚¬ (5í”„ë ˆì„ë§ˆë‹¤)
            if (isMouseDown && score % 5 === 0) {
                missiles.push(new Missile(mouse.x, mouse.y - 20, 0, false));
            }

            // [ìë™ í•„ì‚´ê¸° íŠ¸ë¦¬ê±°]
            // ìŠ¤ì½”ì–´ê°€ 500 ë‹¨ìœ„ì¼ ë•Œ ë°œì‚¬ (0ì  ì œì™¸)
            if (score > 0 && score % SKILL_INTERVAL === 0) {
                fireUltimate();
            }

            ctx.fillStyle = '#121212';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ì ìˆ˜ ë° ìŠ¤í…Œì´ì§€
            if (!boss) score++; 
            scoreEl.innerText = boss ? "WARNING: BOSS" : `SCORE: ${score}`;
            progressBar.style.width = `${Math.min((score / BOSS_SPAWN_SCORE) * 100, 100)}%`;
            
            // ë³´ìŠ¤ ë“±ì¥ ì²´í¬ (2000ì )
            if (!boss && score >= BOSS_SPAWN_SCORE) {
                boss = new Boss();
                stageEl.innerText = "BOSS BATTLE";
                stageEl.style.color = "#ff2a6d";
                fireUltimate(); // ë³´ìŠ¤ ë“±ì¥ ì¶•í¬!
            } else if (!boss) {
                let currentSettings = stages[currentStageIndex];
                stageEl.innerText = currentSettings.name;
                stageEl.style.color = "#ffe600";
                
                if (score === 601 && currentStageIndex === 0) { currentStageIndex = 1; sfxStageClear(); }
                if (score === 1301 && currentStageIndex === 1) { currentStageIndex = 2; sfxStageClear(); }
            }

            // íŒŒí‹°í´
            if (score % 5 === 0) particles.push(new Particle(mouse.x, mouse.y, 'tail'));
            ctx.font = '20px serif';
            particles.forEach((p, i) => {
                p.update(); p.draw();
                if (p.opacity <= 0 || p.size <= 0) particles.splice(i, 1);
            });

            // í”Œë ˆì´ì–´
            ctx.font = `${player.size}px serif`;
            ctx.fillText(player.emoji, mouse.x, mouse.y);

            // ë¯¸ì‚¬ì¼ ì—…ë°ì´íŠ¸ (í™”ë©´ ë°– ì œê±° ë¡œì§ ìˆ˜ì • - ì˜†ìœ¼ë¡œ í¼ì§€ë¯€ë¡œ)
            ctx.font = '20px serif';
            missiles.forEach((m, mIdx) => {
                m.update(); m.draw();
                // í™”ë©´ ìœ„, ì™¼ìª½, ì˜¤ë¥¸ìª½, ì•„ë˜ ë„ˆë¬´ ë©€ë¦¬ ê°€ë©´ ì‚­ì œ
                if (m.y < -50 || m.x < -50 || m.x > canvas.width + 50 || m.y > canvas.height + 50) {
                    missiles.splice(mIdx, 1);
                }
            });

            // ë³´ìŠ¤ì „
            if (boss) {
                boss.update();
                boss.draw();

                missiles.forEach((m, mIdx) => {
                    let dist = Math.hypot(m.x - boss.x, m.y - boss.y);
                    if (dist < boss.size / 2 + m.size) {
                        missiles.splice(mIdx, 1);
                        boss.hp -= 10;
                        createExplosion(m.x, m.y);
                        sfxBossHit();
                        if (boss.hp <= 0) gameClear();
                    }
                });

                let distPlayer = Math.hypot(mouse.x - boss.x, mouse.y - boss.y);
                if (distPlayer < (player.size/2 + boss.size/2) * 0.8) gameOver();

                if (score % 40 === 0) enemies.push(new Enemy(5));
            } else {
                let currentSettings = stages[currentStageIndex];
                if (score % currentSettings.spawnRate === 0) enemies.push(new Enemy(currentSettings.enemySpeed));
            }

            // ì  ê³µí†µ
            enemies.forEach((e, eIdx) => {
                e.update();
                
                ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.rotation);
                ctx.font = `${e.size}px serif`; ctx.fillText(e.emoji, 0, 0); ctx.restore();

                if (e.y > canvas.height + 50) e.markedForDeletion = true;

                let distPlayer = Math.hypot(mouse.x - e.x, mouse.y - e.y);
                if (distPlayer < (player.size/2 + e.size/2) * 0.7) gameOver();

                missiles.forEach((m, mIdx) => {
                    let distMissile = Math.hypot(m.x - e.x, m.y - e.y);
                    if (distMissile < (m.size/2 + e.size/2)) {
                        e.markedForDeletion = true;
                        missiles.splice(mIdx, 1);
                        createExplosion(e.x, e.y);
                        sfxHit();
                    }
                });
            });

            enemies = enemies.filter(e => !e.markedForDeletion);
        }

        function gameOver() {
            isRunning = false; cancelAnimationFrame(animationId);
            document.body.style.cursor = 'default';
            failScreen.classList.remove('hidden');
            sfxGameOver();
        }

        function gameClear() {
            isRunning = false; cancelAnimationFrame(animationId);
            document.body.style.cursor = 'default';
            clearScreen.classList.remove('hidden');
            sfxGameWin();
        }

        function restartGame() { startGame(); }
    </script>
</body>
</html>